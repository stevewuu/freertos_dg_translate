## 堆内存管理

从V9.0.0开始，FreeRTOS应用程序可以完全静态分配，这意味着不需要包含堆内存管理器。本节涵盖：

- FreeRTOS分配RAM时。
- FreeRTOS包含五个示例内存分配方案。
- 每种内存分配方案的用例。
F
### 先决条件

你需要很好的理解C编程才能使用FreeRTOS。 具体来说，你应该熟悉：

- 如何构建C项目，包括编译和链接阶段。
- 堆栈和堆的概念。
- 标准的C库malloc（）和free（）函数。

### 动态内存分配及其与FreeRTOS的关联

本指南介绍了诸如任务，队列，信号量和事件组等内核对象。 要使FreeRTOS尽可能易于使用，这些内核对象在编译时不是静态分配的，而是在运行时动态分配的。 每次创建内核对象时，FreeRTOS都会分配RAM，并且每次内核对象被删除时都会释放RAM。 此策略减少了设计和规划工作，简化了API，并最大限度地减少了RAM占用空间。

动态内存分配是一个C编程概念。 这不是FreeRTOS或多任务特有的概念。 这与FreeRTOS相关，因为内核对象是动态分配的，而通用编译器提供的动态内存分配方案并不总是适用于实时应用。

可以使用标准C库malloc（）和free（）函数来分配内存，但可能由于以下一个或多个原因而不适合或不适用：

- 它们并不总是可用于小型嵌入式系统。
- 它们的实现可能相对较大，占用有价值的代码空间。
- 它们很少是线程安全的。
- 他们不是确定性的。 执行这些功能所用的时间将与调用有所不同。
- 他们可能遭受分裂。 如果将堆中的空闲RAM分解为彼此分离的小块，则认为该堆被分割。 如果堆被分段，那么如果堆中没有单个空闲块足够大以包含块，那么分配块的尝试将失败，即使堆中所有单独的空闲块的总大小比 无法分配的块的大小。
- 他们可能会使链接器配置复杂化。
- 如果允许堆空间增长到其他变量使用的内存中，则它们可能成为难以调试的错误源。

### 动态内存分配选项

较早版本的FreeRTOS使用内存池分配方案，其中不同大小内存块的池在编译时预先分配，然后由内存分配函数返回。尽管这是实时系统中常用的方案，但却产生了很多支持请求。该方案因为无法有效地使用RAM而使其成为真正的小型嵌入式系统而被放弃。

FreeRTOS现在将内存分配作为便携层的一部分（而不是核心代码库的一部分）。这是对嵌入式系统动态内存分配和时序要求的认识。单个动态内存分配算法仅适用于一部分应用程序。此外，从核心代码库中移除动态内存分配，可以使应用程序编写者在适当时提供自己的特定实现。

当FreeRTOS需要RAM时，它调用pvPortMalloc（）而不是malloc（）。当RAM被释放时，内核调用vPortFree（）而不是free（）。 pvPortMalloc（）与标准C库malloc（）函数具有相同的原型。 vPortFree（）与标准C库free（）函数具有相同的原型。

pvPortMalloc（）和vPortFree（）是公共函数，所以它们也可以从应用程序代码中调用。

FreeRTOS提供了pvPortMalloc（）和vPortFree（）的五个示例实现，所有这些在这里都有记录。 FreeRTOS应用程序可以使用这些示例实现之一或提供自己的。

这五个例子在位于FreeRTOS / Source / portable / MemMang目录中的heap_1.c，heap_2.c，heap_3.c，heap_4.c和heap_5.c源文件中定义。

#### 内存分配示例

由于FreeRTOS应用程序可以完全静态分配，因此不需要包含堆内存管理器。

### Heap_1

小型专用嵌入式系统通常只在调度程序启动之前创建任务和其他内核对象。在应用程序开始执行任何实时功能之前，内存是由内核动态分配的，并且内存在应用程序的整个生命周期中都保持分配状态。这意味着所选择的分配方案不必考虑任何更复杂的存储器分配问题，例如确定性和分段。它可以考虑代码大小和简单性等属性。

Heap_1.c实现了一个非常基本的pvPortMalloc()。它没有实现vPortFree()。从不删除任务或其他内核对象的应用程序可以使用heap_1。

一些否则会禁止使用动态内存分配的商业关键和安全关键系统也可以使用heap_1。关键系统通常禁止动态内存分配，因为与非确定性，内存碎片和分配失败相关的不确定性，但heap_1总是确定性的，不能片段化内存。

当调用pvPortMalloc（）时，heap_1分配方案将一个简单的数组细分为更小的块。该数组被称为FreeRTOS堆。

数组的总大小（以字节为单位）由FreeRTOSConfig.h中的定义configTOTAL_HEAP_SIZE设置。以这种方式定义大型数组可能会使应用程序看起来消耗大量RAM，即使在从阵列分配任何内存之前。

